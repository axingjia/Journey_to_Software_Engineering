# Refactoring

## Foreword to the First Edition
* "Refactoring" was conceived in Smalltalk circles, but it wasn't long before it found its way into other programming language camps. Because refactoring is integral to framework development, the term comes up quickly when "frameworkers" talk about their craft. It comes up when they refine their class hierarchies and when they rave about how many lines of code they were able to delete. Frameworkers know that a framework won't be right the first time around--it must evolve as they gain experience. They also know that the code will be read and modified more frequently than it will be written. The key to keeping code readable and modifiable is refactoring--for frameworks, in particular, but also for software in general.
* So, what's the problem? Simply this: Refactoring is risky. It requires changes to working code that can introduce subtle bugs. Refactoring, it not done properly, can set you back days, even weeks. And refactoring becomes riskier when practiced informally or ad hoc. You start digging in the code. Soon you discover new opportunities for change, and you dig deeper. The more you dig, the more stuff you turn up.. and the more changes you make. Eventually you dig yourself into a hole you can't get out of. To avoid digging your own grave, refactoring must be done systematically. When my coauthors and I wrote Design Patterns, we mentioned t hat design patterns provide targets for refactorings. However, identifying the target is only one part of the problem; transforming your code so that you get there is another challenge.
* Martin Fowler and the contributing authors make an invalable contribution to object-oriented software development by shedding light on the refactoring process. This book explains the principles and best practices of refactoring, and points out when and where you should start digging in your code to improve it. At the book's core is a comprehensive catalog of refactorings. Each refactoring describes the motivation and mechanics of a proven code transformation. Some of the refactoring, such as Extract method or Move Field, may seem obvious.
* But don't be fooled. Understanding the mechanics of such refactoring is the key to refactoring in a disciplined way. The refactorings in this book will help you change your code one small step at a time, thus reducing the risks of evolving your design. You will quickly add these refactorings and their names to your development vocabulary.
* My first experience with disciplined, "one step at a time" refactoring was when I was pair-programming at 30,000 feet with Kent Beck. He made sure that we applied refactoring from this book's catalog one step at a time. I was amazed at how well this practice worked. Not only did my confidence in the resulting code increase, I also felt less stressed. I highly recommend you try these refactorings: You and your code will feel much better for it.
* --Erich Gamma, Object Technology Internatinoal, Inc. January 1999

## Preface
* Once upon a time, a consultant made a visit to a development project in order to look at some of the code that had been written. As he wandered through the class hierarchy at the center of the system, the consultant found it rather messy. The higher-level classes made certain assumptions about how the classes would work--assumptions that were embodied in inherited code. That code didn't suit all the subclasses, however, and was overridden quite heavily. Slight modifications to the superclass would have greatly reduced the need to override it. In other places, an intention of the superclass had not been properly understood, and behavior present in the superclass was duplicated. In yet other places, several subclasses did the same thing with code that could clearly be moved up the hierarchy.
* The consultant recommended to the project management that the code be looked at and cleaned up--but the project management wasn't enthusiastic. The code seemed to work and there were considerable schedule pressures. The managers said they would get around to it at some later point.
* The consultant had also shown what was going on to the programmers working on the hierarchy. The programmers were keen and saw the problem. They knew that it wasn't really their fault; sometimes, a new pair of eyes is needed to spot the problem. So the programmers spent a day or two cleaning up the hierarchy. When finished, they had removed half the code in the hierarchy without reducing its functionality. They were pleased with the result and found that it became quicker and easier both to add new classes and to use the classes in the rest of the system.
* The project management was not pleased. Schedules were tight and there was a lot of work to do. These two programmers had spent two days doing work that added nothing to the many features the system had to deliver in a few months' time. The old code had worked just fine. Yes, the design was a bit more "pure" and a bit more "clean". But the project had to ship code that worked, not code that would please the academic. The consultant suggested that a similar cleanup should be done on other central parts of the system, which might halt the project for a week or two. ALl this was to make the code look better, not to make it do anything it didn't already do.
* How do you feel about this story? Do you think the consultant was right to suggest further cleanup? Or do you follow that old engineering adage, "if it works, don't fix it"?
* I must admit to some bias here. I was that consultant, six months later, the project failed, in large part because the code was too complex to debug or tune to acceptable performance.
* The consultant Kent Beck was brought in to restart the project--an exercise that involved rewriting almost the whole system from scratch. He did several things differently, but one of the most important changes was to insist on continuous cleaning up the code using refactoring. The improved effectiveness of the team, and the role refactoring played, is what inspired me to write the first edition of this book--so I could pass on the knowledge that Kent and others have acquired by using refactoring to improve the quality of software.
* Since then, refactoring has become an accepted part of the vocabulary of programming. And the original book has stood up rather well. However, eighteen years is an old age for a programming book, so I felt it was time to go back and rework it. Doing this had me rewrite pretty much every page in the book. But, in a sense, very little has changed. The essence of refactoring is the same; most of the key refactoring remain essentially the same. But I do hope that the rewriting will help more people learn how to do refactoring effectively.

### What is Refactoring?
* Refactoring is the process of changing a software system in a way that does not alter the external behavior of the code yet improves its internal structure. It is a disciplined way to clean up code that minimizes the chances of introducing bugs. In essence, when you refactor, you are improving the design of the code after it has been written.
* "Improving the design after it has been written." That's an odd turn of phrase. For much of the history of software development, most people believed that we design first, and only when done with design should we code. Over time, the code will be modified, and the integrity of the system--its structure according to that design--gradually fades. The code slowly sinks from engineering to hacking. 
* Refactoring is the opposite of this practice. With refactoring, we can take a bad, even chaotic, design and rework it into well-structured code. Each step is simple--even simplistic. I move a field from one class to another, pull some code out of a method to make it into its own method, or push some code up or down a hierarchy. Yet the cumulative effect of these small changes can radically improve the design. It is the exact reverse of the notion of software decay.
* With refactoring, the balance of work changes. I found that design, rather than occuring all up front, occur continuously during development. As I build the system, I learn how to improve the design. The result of this interaction is a program whose design stays good as development continues.

## What's In This Book?
* This book is a guide to refactoring; it is written for a professional programmer. My aim is to show you how to do refactoring in a controlled and efficient manner. You will learn to refactor in such a way that you don't introduce